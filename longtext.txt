package server

import (
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/lguibr/pongo/game"
	"github.com/lguibr/pongo/utils"
	"golang.org/x/net/websocket"
)

func (s *Server) HandleSubscribe(g *game.Game) func(ws *websocket.Conn) {
	return func(ws *websocket.Conn) {

		fmt.Println("New Connection from client: ", ws.RemoteAddr())
		fmt.Println(g)

		s.conns[ws] = true

		unsubscribePlayer, player := g.SubscribePlayer()

		//INFO Reading the direction from the client
		go func() { s.readLoop(ws, player.Paddle.SetDirection, unsubscribePlayer) }()

		//INFO Writing the game state to the client
		for {
			payload := g.ToJson()
			_, err := ws.Write(payload)
			if err != nil {
				fmt.Println("Error writing to client: ", err)
				unsubscribePlayer()
				delete(s.conns, ws)
				break
			}
			time.Sleep(utils.Period)
		}

	}
}

func (s *Server) HandleGetSit(g *game.Game) func(w http.ResponseWriter, r *http.Request) {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		_, err := io.WriteString(w, string(g.ToJson()))
		if err != nil {
			fmt.Println("Error writing to client: ", err)
		}
	}
}
package server

import (
	"fmt"
	"io"

	"golang.org/x/net/websocket"
)

type Server struct {
	conns map[*websocket.Conn]bool
}

func NewServer() *Server {
	return &Server{conns: make(map[*websocket.Conn]bool)}
}

func (s *Server) readLoop(ws *websocket.Conn, callback func(buffer []byte), closeHandler func()) {
	defer func() {
		closeHandler()
		ws.Close()
	}()

	buffer := make([]byte, 1024)
	for {
		size, err := ws.Read(buffer)
		if err != nil {
			fmt.Println("Error reading from client:", err)
			if err == io.EOF {
				fmt.Println("Connection closed by the client:", err)
				break
			}
			continue
		}
		callback(buffer[:size])
	}
}
package utils

import (
	"math"
	"math/rand"
	"testing"
	"time"
)

// DEV Matrix
func NewMatrixesOfRotation() [4][2][2]int {
	return [4][2][2]int{
		{{1, 0}, {0, 1}},
		{{0, 1}, {-1, 0}},
		{{-1, 0}, {0, -1}},
		{{0, -1}, {1, 0}},
	}
}

// DEV Matrix
func TransformMatrix(matrix [2][2]int, tMatrix [2][2]int) [2][2]int {
	var transformedMatrix [2][2]int
	for i := range matrix {
		var vector [2]int
		x, y := TransformVector(tMatrix, matrix[i][0], matrix[i][1])
		vector = [2]int{x, y}
		transformedMatrix[i] = vector
	}
	return transformedMatrix
}

// DEV Matrix
var MatrixesOfRotation = NewMatrixesOfRotation()

// DEV Vector
func TransformVector(tMatrix [2][2]int, x int, y int) (int, int) {
	return tMatrix[0][0]*x + tMatrix[0][1]*y, tMatrix[1][0]*x + tMatrix[1][1]*y
}

// DEV Vector
func RotateVector(index int, x int, y int, canvasWidth int, canvasHeight int) (int, int) {
	return TransformVector(MatrixesOfRotation[index], x, y)
}

// DEV Vector
func NewPositiveRandomVector(vectorMaxLen int) [2]int {
	maxCoordinateSize := int(math.Max(float64(vectorMaxLen)/(2*math.Sqrt(2)), 1.0))
	x := rand.Intn(maxCoordinateSize)
	rand.Seed(time.Now().UnixNano())
	y := rand.Intn(maxCoordinateSize)

	return [2]int{x, y}
}

// DEV Vector
func NewRandomVector(vectorMaxLen int) [2]int {
	maxCoordinateSize := int((math.Max(float64(vectorMaxLen)/2*math.Sqrt(2), 1.0)))
	x := rand.Intn(maxCoordinateSize)*2 - maxCoordinateSize
	rand.Seed(time.Now().UnixNano())
	y := rand.Intn(maxCoordinateSize)*2 - maxCoordinateSize
	return [2]int{x, y}
}

// DEV Vector
func CheckPointWithinBounds(x int, y int, topSide [2]int, bottomOppositeSide [2]int) bool {
	return x >= topSide[0] && x <= bottomOppositeSide[0] && y >= topSide[1] && y <= bottomOppositeSide[1]
}

// DEV Vector
func SubtractVectors(vectorA [2]int, vectorB [2]int) [2]int {
	return [2]int{vectorA[0] - vectorB[0], vectorA[1] - vectorB[1]}
}

// DEV Vector
func SumVectors(vectorA [2]int, vectorB [2]int) [2]int {
	return [2]int{vectorA[0] + vectorB[0], vectorA[1] + vectorB[1]}
}

// DEV Vector
func MultiplyVectorByScalar(vectorA [2]int, scalar int) [2]int {
	return [2]int{vectorA[0] * scalar, vectorA[1] * scalar}
}

// DEV Vector
func DotProduct(vectorA, vectorB []int) int {
	if len(vectorA) != len(vectorB) || len(vectorA) == 0 {
		panic("vectors must have the same length")
	}
	var result int
	for i := range vectorA {
		result += vectorA[i] * vectorB[i]
	}
	return result
}

// DEV Vector
func Equal(a, b []int) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

// DEV Vector
func CrossProduct(vectorA, vectorB []int) []int {
	if len(vectorA) != 3 || len(vectorB) != 3 {
		panic("vectors must have length 3")
	}
	return []int{
		vectorA[1]*vectorB[2] - vectorA[2]*vectorB[1],
		vectorA[2]*vectorB[0] - vectorA[0]*vectorB[2],
		vectorA[0]*vectorB[1] - vectorA[1]*vectorB[0],
	}
}

// DEV Vector
func SwapVectorCoordinates(vector [2]int) [2]int {
	return [2]int{vector[1], vector[0]}
}

// DEV Vector
func NewRandomPositiveVectors(numberOfVectors, maxVectorSize int) [][2]int {
	seedVectors := make([][2]int, numberOfVectors)
	for index := range seedVectors {
		currentLength := rand.Intn(maxVectorSize)
		if currentLength == 0 || currentLength > maxVectorSize {
			currentLength = maxVectorSize
		}
		seedVectors[index] = NewPositiveRandomVector(currentLength)
	}
	return seedVectors
}

// DEV Vector
func Distance(x1, y1, x2, y2 int) float64 {
	deltaX := x2 - x1
	deltaY := y2 - y1

	return math.Sqrt(math.Pow(float64(deltaX), 2) + math.Pow(float64(deltaY), 2))
}

// DEV Number
func RandomNumber(amplitude int) int {
	return rand.Intn(amplitude*2) - amplitude
}

var randomNumberN func(amplitude int) int

func RandomNumberN(amplitude int) int {
	randomNumberN = func(amplitude int) int {
		value := rand.Intn(amplitude*2) - amplitude
		if value == 0 {
			value = RandomNumberN(amplitude)
		}
		return value
	}
	return randomNumberN(amplitude)
}

// DEV Number
func Abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

// DEV string
func DirectionFromString(direction string) string {
	if direction == "ArrowLeft" {
		return "left"
	} else if direction == "ArrowRight" {
		return "right"
	}
	return ""
}

// DEV color
func NewRandomColor() [3]int {
	return [3]int{rand.Intn(255), rand.Intn(255), rand.Intn(255)}
}

func AssertPanics(t *testing.T, testingFunction func(), message string) (panics bool, errorMessage string) {

	panics = false
	errorMessage = ""

	deferFunc := func() {
		if r := recover(); r != nil {
			panics = true
			errorMessage = r.(string)
		}
	}

	func() {
		defer deferFunc()
		testingFunction()
	}()

	return panics, errorMessage
}
package utils

import (
	"fmt"
	"math"
	"testing"
)

func TestDirectionFromString(t *testing.T) {
	testCases := map[string]string{
		"ArrowLeft":  "left",
		"ArrowRight": "right",
		"ArrowUp":    "",
		"":           "",
	}

	for input, expected := range testCases {
		result := DirectionFromString(input)
		if result != expected {
			t.Errorf("DirectionFromString(%s) = %s, want %s", input, result, expected)
		}
	}
}

func TestNewRandomColor(t *testing.T) {
	// Test that all elements of the returned array are between 0 and 255 inclusive
	for i := 0; i < 100; i++ {
		color := NewRandomColor()
		for i := range color {
			if color[i] < 0 || color[i] > 255 {
				t.Errorf("NewRandomColor() returned an invalid color value: %d", color[i])
			}
		}
	}
}

func TestNewMatrixesOfRotation(t *testing.T) {
	matrixes := NewMatrixesOfRotation()
	expectedMatrixes := [4][2][2]int{
		{{1, 0}, {0, 1}},
		{{0, 1}, {-1, 0}},
		{{-1, 0}, {0, -1}},
		{{0, -1}, {1, 0}},
	}
	for i := range matrixes {
		for j := range matrixes[i] {
			for k := range matrixes[i][j] {
				if matrixes[i][j][k] != expectedMatrixes[i][j][k] {
					t.Errorf("NewMatrixesOfRotation() returned an invalid matrix at index [%d][%d][%d]: %d, want %d", i, j, k, matrixes[i][j][k], expectedMatrixes[i][j][k])
				}
			}
		}
	}
}

func TestTransformVector(t *testing.T) {
	cardinalX := [2]int{1, 0}
	expectedValues := [][2]int{{1, 0}, {0, -1}, {-1, 0}, {0, 1}}
	for index, matrixOfRotation := range MatrixesOfRotation {
		x, y := TransformVector(matrixOfRotation, cardinalX[0], cardinalX[1])
		if x != expectedValues[index][0] || y != expectedValues[index][1] {
			t.Error("Expected ", expectedValues[index], " got ", [2]int{x, y}, "on index", index)
		}
	}
}

func TestTransformVector2(t *testing.T) {
	testCases := []struct {
		tMatrix  [2][2]int
		vector   [2]int
		expected [2]int
		name     string
	}{
		{[2][2]int{{1, 0}, {0, 1}}, [2]int{1, 1}, [2]int{1, 1}, "Identity transform"},
		{[2][2]int{{0, -1}, {1, 0}}, [2]int{1, 1}, [2]int{-1, 1}, "90 degrees rotation"},
		{[2][2]int{{-1, 0}, {0, -1}}, [2]int{1, 1}, [2]int{-1, -1}, "180 degrees rotation"},
		{[2][2]int{{0, 1}, {-1, 0}}, [2]int{1, 1}, [2]int{1, -1}, "270 degrees rotation"},
		{[2][2]int{{2, 0}, {0, 2}}, [2]int{1, 1}, [2]int{2, 2}, "Diagonal scaling"},
	}
	for _, tc := range testCases {
		x, y := TransformVector(tc.tMatrix, tc.vector[0], tc.vector[1])
		result := [2]int{x, y}
		if result != tc.expected {
			t.Errorf("TransformVector(%v, %v) = %v, want %v in test case %s", tc.tMatrix, tc.vector, result, tc.expected, tc.name)
		}
	}
}

func TestRotateVector(t *testing.T) {
	type TestRotateVectorCase struct {
		Vector         [2]int
		index          int
		expectedVector [2]int
	}
	testCases := []TestRotateVectorCase{
		{[2]int{1, 0}, 0, [2]int{1, 0}},
		{[2]int{1, 0}, 1, [2]int{0, -1}},
		{[2]int{1, 0}, 2, [2]int{-1, 0}},
		{[2]int{1, 0}, 3, [2]int{0, 1}},
	}
	for caseIndex, testCase := range testCases {
		x, y := RotateVector(testCase.index, testCase.Vector[0], testCase.Vector[1], 100, 100)
		if x != testCase.expectedVector[0] || y != testCase.expectedVector[1] {
			t.Error("Expected ", testCase.expectedVector, " got ", [2]int{x, y}, " for case ", caseIndex)
		}
	}
}

func TestRotateVector2(t *testing.T) {
	testCases := []struct {
		index      int
		vector     [2]int
		canvasSize int
		expected   [2]int
		name       string
	}{
		{0, [2]int{1, 1}, 2, [2]int{1, 1}, "0 degrees rotation"},
		{1, [2]int{1, 1}, 2, [2]int{1, -1}, "90 degrees rotation"},
		{2, [2]int{1, 1}, 2, [2]int{-1, -1}, "180 degrees rotation"},
		{3, [2]int{1, 1}, 2, [2]int{-1, 1}, "270 degrees rotation"},
	}
	for _, tc := range testCases {
		x, y := RotateVector(tc.index, tc.vector[0], tc.vector[1], tc.canvasSize, tc.canvasSize)
		result := [2]int{x, y}
		if result != tc.expected {
			t.Errorf("RotateVector(%d, %v, %d, %d) = %v, want %v on test case %s",
				tc.index, tc.vector, tc.canvasSize, tc.canvasSize, result, tc.expected, tc.name)
		}
	}
}
func TestTransformMatrix(t *testing.T) {
	matrix := [2][2]int{{1, 2}, {3, 4}}
	tMatrix := [2][2]int{{2, 0}, {0, 2}}
	expected := [2][2]int{{2, 4}, {6, 8}}
	result := TransformMatrix(matrix, tMatrix)
	for i := range matrix {
		for j := range matrix[i] {
			if result[i][j] != expected[i][j] {
				t.Errorf("TransformMatrix(%v, %v) = %v, want %v", matrix, tMatrix, result, expected)
			}
		}
	}
}

func TestNewPositiveRandomVector(t *testing.T) {
	size := 10
	vector := NewPositiveRandomVector(size)
	if vector[0] < 0 || vector[1] < 0 {
		t.Errorf("NewPositiveRandomVector(%d) = %v, want positive values", size, vector)
	}
}

func TestNewRandomVector(t *testing.T) {
	size := 10
	// Call the function multiple times and check if the returned vector is within bounds
	for i := 0; i < 100; i++ {
		vector := NewRandomVector(size)
		if math.Abs(float64(vector[0])) > float64(size) || math.Abs(float64(vector[1])) > float64(size) {
			t.Errorf("Expected vector to be within bounds, got %v", vector)
		}
	}
}

func TestCheckPointWithinBounds(t *testing.T) {
	type CheckPointWithinBoundsTestCase struct {
		x                  int
		y                  int
		topSide            [2]int
		bottomOppositeSide [2]int
		expected           bool
	}

	testCases := []CheckPointWithinBoundsTestCase{
		{5, 5, [2]int{0, 0}, [2]int{10, 10}, true},
		{15, 15, [2]int{0, 0}, [2]int{10, 10}, false},
		{-5, -5, [2]int{-10, -10}, [2]int{0, 0}, true},
		{0, 0, [2]int{-10, -10}, [2]int{0, 0}, true},
	}

	for _, test := range testCases {
		result := CheckPointWithinBounds(test.x, test.y, test.topSide, test.bottomOppositeSide)
		if result != test.expected {
			t.Errorf("Expected %v for point %d,%d within bounds %v,%v, got %v", test.expected, test.x, test.y, test.topSide, test.bottomOppositeSide, result)
		}
	}
}

func TestAbs(t *testing.T) {
	testCases := []struct {
		x        int
		expected int
		name     string
	}{
		{1, 1, "Positive value"},
		{-1, 1, "Negative value"},
		{0, 0, "Zero value"},
	}
	for _, tc := range testCases {
		result := Abs(tc.x)
		if result != tc.expected {
			t.Errorf("Abs(%d) = %d, want %d", tc.x, result, tc.expected)
		}
	}
}

func TestSubtractVectors(t *testing.T) {
	testCases := []struct {
		vectorA  [2]int
		vectorB  [2]int
		expected [2]int
		name     string
	}{
		{[2]int{1, 1}, [2]int{1, 1}, [2]int{0, 0}, "Subtracting same vectors"},
		{[2]int{1, 2}, [2]int{2, 3}, [2]int{-1, -1}, "Subtracting different vectors"},
		{[2]int{-1, -1}, [2]int{1, 1}, [2]int{-2, -2}, "Subtracting negative vectors"},
	}
	for _, tc := range testCases {
		result := SubtractVectors(tc.vectorA, tc.vectorB)
		if result != tc.expected {
			t.Errorf("SubtractVectors(%v, %v) = %v, want %v", tc.vectorA, tc.vectorB, result, tc.expected)
		}
	}
}

func TestSumVectors(t *testing.T) {
	testCases := []struct {
		vectorA  [2]int
		vectorB  [2]int
		expected [2]int
		name     string
	}{
		{[2]int{1, 1}, [2]int{1, 1}, [2]int{2, 2}, "Summing same vectors"},
		{[2]int{1, 2}, [2]int{2, 3}, [2]int{3, 5}, "Summing different vectors"},
		{[2]int{-1, -1}, [2]int{1, 1}, [2]int{0, 0}, "Summing negative vectors"},
	}

	for _, tc := range testCases {
		result := SumVectors(tc.vectorA, tc.vectorB)
		if result != tc.expected {
			t.Errorf("SumVectors(%v, %v) = %v, want %v", tc.vectorA, tc.vectorB, result, tc.expected)
		}
	}
}

func TestMultiplyVectorByScalar(t *testing.T) {

	type MultiplyVectorByScalarTestCase struct {
		vectorA  [2]int
		scalar   int
		expected [2]int
	}

	testCases := []MultiplyVectorByScalarTestCase{
		{[2]int{1, 1}, 2, [2]int{2, 2}},
		{[2]int{-1, -1}, 2, [2]int{-2, -2}},
		{[2]int{1, 2}, -1, [2]int{-1, -2}},
		{[2]int{0, 0}, 2, [2]int{0, 0}},
	}

	for _, test := range testCases {
		result := MultiplyVectorByScalar(test.vectorA, test.scalar)
		if result != test.expected {
			t.Errorf("Expected %v for vector %v multiplied by scalar %d, got %v", test.expected, test.vectorA, test.scalar, result)
		}
	}
}

func TestDotProduct(t *testing.T) {
	type DotProductTestCase struct {
		vectorA  []int
		vectorB  []int
		expected int
		panics   bool
	}

	testCases := []DotProductTestCase{
		{[]int{1, 2}, []int{2, 3}, 8, false},
		{[]int{1, 1}, []int{1, 1}, 2, false},
		{[]int{-1, -2}, []int{2, -1}, 0, false},
		{[]int{0, 0, 0}, []int{0, 0, 0}, 0, false},
		{[]int{0, 1, 2}, []int{1, 2, 3}, 8, false},
		{[]int{1, 2}, []int{2}, 0, true},
		{[]int{}, []int{2, 3}, 0, true},
		{[]int{}, []int{}, 0, true},
	}

	for _, test := range testCases {
		if test.panics {
			panics, _ := AssertPanics(t, func() { DotProduct(test.vectorA, test.vectorB) }, "")
			if !panics {
				t.Errorf("Expected panic for vectors %v and %v", test.vectorA, test.vectorB)
			}
		} else {
			result := DotProduct(test.vectorA, test.vectorB)
			if result != test.expected {
				t.Errorf("Expected %v for vectors %v and %v, got %v", test.expected, test.vectorA, test.vectorB, result)
			}
		}
	}
}

func TestEqual(t *testing.T) {
	type EqualTestCase struct {
		a        []int
		b        []int
		expected bool
	}
	testCases := []EqualTestCase{
		{[]int{1, 2, 3}, []int{1, 2, 3}, true},
		{[]int{-1, 2, 1}, []int{4, -1, 2}, false},
		{[]int{3, 1, 2}, []int{3, 1, 2}, true},
		{[]int{1, 1, 1}, []int{1, 1, 1, 1}, false},
	}

	for _, test := range testCases {
		result := Equal(test.a, test.b)
		if result != test.expected {
			t.Errorf("Expected %v for vectors %v and %v, got %v", test.expected, test.a, test.b, result)
		}
	}
}

func TestCrossProduct(t *testing.T) {
	type CrossProductTestCase struct {
		vectorA  []int
		vectorB  []int
		expected []int
		panics   bool
	}

	testCases := []CrossProductTestCase{
		{[]int{1, 0, 0}, []int{0, 1, 0}, []int{0, 0, 1}, false},
		{[]int{0, 1, 0}, []int{0, 0, 1}, []int{1, 0, 0}, false},
		{[]int{0, 0, 1}, []int{1, 0, 0}, []int{0, 1, 0}, false},
		{[]int{1, 2, 3}, []int{4, 5}, nil, true},
		{[]int{}, []int{}, nil, true},
	}

	for _, test := range testCases {
		if test.panics {
			panics, _ := AssertPanics(t, func() { CrossProduct(test.vectorA, test.vectorB) }, "")
			if !panics {
				t.Errorf("Expected panic for vectors %v and %v", test.vectorA, test.vectorB)
			}
		} else {
			result := CrossProduct(test.vectorA, test.vectorB)
			if !Equal(result, test.expected) {
				t.Errorf("Expected %v for vectors %v and %v, got %v", test.expected, test.vectorA, test.vectorB, result)
			}
		}
	}
}

func TestSwapVectorCoordinates(t *testing.T) {

	type SwapVectorCoordinatesTestCase struct {
		vector   [2]int
		expected [2]int
	}

	testCases := []SwapVectorCoordinatesTestCase{
		{[2]int{1, 2}, [2]int{2, 1}},
		{[2]int{-1, 2}, [2]int{2, -1}},
		{[2]int{3, 0}, [2]int{0, 3}},
		{[2]int{-1, -1}, [2]int{-1, -1}},
	}

	for _, test := range testCases {
		result := SwapVectorCoordinates(test.vector)
		if result != test.expected {
			t.Errorf("Expected %v for vector %v, got %v", test.expected, test.vector, result)
		}
	}
}

func TestNewRandomPositiveVectors(t *testing.T) {
	testCases := []struct {
		n      int
		size   int
		panics bool
		name   string
	}{
		{3, 10, false, "3 positive random vectors of size 10"},
		{5, 20, false, "5 positive random vectors of size 20"},
		{2, 5, false, "2 positive random vectors of size 5"},
		{100, 500, false, "100 positive random vectors of size 500"},
		{1, 0, true, "100 positive random vectors of size 0 should panics"},
		{0, 0, false, "0 positive random vectors of size 0 should panics"},
	}
	for _, tc := range testCases {
		if tc.panics {
			panics, err := AssertPanics(t, func() { NewRandomPositiveVectors(tc.n, tc.size) }, "")
			if !panics {
				t.Errorf("Expected panic for %s, got %v", tc.name, err)
			}
		} else {

			result := NewRandomPositiveVectors(tc.n, tc.size)
			if len(result) != tc.n {
				t.Errorf("NewRandomPositiveVectors(%d, %d) = %v, want %d vectors", tc.n, tc.size, result, tc.n)
			}

			for _, vector := range result {
				if vector[0] < 0 || vector[1] < 0 {
					t.Errorf("NewRandomPositiveVectors(%d, %d) = %v, want positive values", tc.n, tc.size, result)
					break
				}
			}
		}
	}
}

func TestDistance(t *testing.T) {
	type DistanceTestCase struct {
		x1, y1, x2, y2 int
		expected       float64
	}

	testCases := []DistanceTestCase{
		{1, 1, 2, 2, 1.4142135623730951},
		{-1, 2, 4, -1, 5.830951894845301},
		{0, 0, 3, 4, 5.0},
		{-2, -3, 2, 4, 8.06225774829855},
		{-2, -3, -2, -3, 0},
		{1, 1, 1, 1, 0},
	}

	for _, test := range testCases {
		result := Distance(test.x1, test.y1, test.x2, test.y2)
		if result != test.expected {
			t.Errorf("Expected %v for point1(%d,%d) and point2(%d,%d), got %v", test.expected, test.x1, test.y1, test.x2, test.y2, result)
		}
	}
}

func TestRandomNumber(t *testing.T) {
	type RandomNumberTestCase struct {
		amplitude   int
		expectedMin int
		expectedMax int
	}

	testCases := []RandomNumberTestCase{
		{10, -10, 10},
		{5, -5, 5},
		{7, -7, 7},
	}

	for _, test := range testCases {
		result := RandomNumber(test.amplitude)
		if result < test.expectedMin || result > test.expectedMax {
			t.Errorf("Expected random number between %d and %d for amplitude %d, got %d", test.expectedMin, test.expectedMax, test.amplitude, result)
		}
	}
}

func TestRandomNumberN(t *testing.T) {
	// Set up test cases
	testCases := []struct {
		amplitude int
		min       int
		max       int
	}{
		{1, -1, 1},
		{2, -2, 2},
		{3, -3, 3},
	}

	// Iterate over test cases
	for _, test := range testCases {
		for i := 0; i < 100; i++ {
			// Call the function and save the result
			result := RandomNumberN(test.amplitude)

			// Check that the result is within the expected range
			if result < test.min || result > test.max {
				t.Errorf("Expected a number between %d and %d, got %d", test.min, test.max, result)
			}
		}
	}
}
func TestAssertPanics(t *testing.T) {
	t.Run("Panicking function", func(t *testing.T) {
		// Function that is expected to panic
		shouldPanic := func() { panic("Panic occurred") }
		// Call our AssertPanics function with the above function
		panics, err := AssertPanics(t, shouldPanic, " - PosMessage")
		if !panics {
			t.Errorf("Expected panic, got %v", err)
		}
	})
	t.Run("Non-panicking function", func(t *testing.T) {
		// Function that is NOT expected to panic
		shouldNotPanic := func() { fmt.Println("Hello, world") }
		// Call our AssertPanics function with the above function
		// and wrap it with a defer function to catch a panic if it happens
		defer func() {
			if r := recover(); r != nil {
				fmt.Println("Recovered:", r)
				// t.Errorf("The code panicked, but it should not have")
			}
		}()
		panics, err := AssertPanics(t, shouldNotPanic, "Hello, world")
		if panics {
			t.Errorf("Expected no panic, got %v", err)
		}
	})
}
package utils

import "time"

const (
	Period = 20 * time.Millisecond

	CanvasSize = 576 //INFO Must be divisible by GridSize
	GridSize   = 12  //INFO Must be divisible by 2

	CellSize    = CanvasSize / GridSize
	MinVelocity = CanvasSize / 200
	MaxVelocity = CanvasSize / 150

	NumberOfVectors       = GridSize * 2
	MaxVectorSize         = GridSize
	NumberOfRandomWalkers = GridSize / 4
	NumberOfRandomSteps   = GridSize / 2

	BallSize     = CellSize / 4
	PaddleLength = CellSize * 3
	PaddleWeight = CellSize / 2
)

var CellTypes = map[string]string{
	"Empty": "Empty",
	"Brick": "Brick",
	"Block": "Block",
}
package main

import (
	"fmt"
	"net/http"

	"github.com/lguibr/pongo/game"
	"github.com/lguibr/pongo/server"
	"golang.org/x/net/websocket"
)

func main() {
	wsServer := server.NewServer()
	game := game.StartGame()

	fmt.Println("Game started:")
	fmt.Println(game)

	http.HandleFunc("/", wsServer.HandleGetSit(game))

	http.Handle("/subscribe", websocket.Handler(wsServer.HandleSubscribe(game)))

	panic(http.ListenAndServe(":3001", nil))

}
package game

import (
	"github.com/lguibr/pongo/utils"
)

type Canvas struct {
	Grid       Grid `json:"grid"`
	Width      int  `json:"width"`
	Height     int  `json:"height"`
	GridSize   int  `json:"gridSize"`
	CanvasSize int  `json:"canvasSize"`
	CellSize   int
}

func NewCanvas(size, gridSize int) *Canvas {

	if size == 0 {
		size = utils.CanvasSize
	}
	if gridSize == 0 {
		gridSize = utils.GridSize
	}
	if size%gridSize != 0 {
		panic("Size must be a multiple of gridSize")
	}

	if gridSize < 6 {
		panic("GridSize must be greater or equal than 6")
	}

	return &Canvas{
		Grid:       NewGrid(gridSize),
		Width:      size,
		Height:     size,
		GridSize:   gridSize,
		CanvasSize: size,
		CellSize:   size / gridSize,
	}
}
package game

import (
	"encoding/json"
	"testing"
	"time"

	"github.com/lguibr/pongo/utils"
)

func TestGame_HasPlayer(t *testing.T) {
	testCases := []struct {
		players   [4]*Player
		hasPlayer bool
	}{
		{[4]*Player{{Id: "player1"}, nil, nil}, true},
		{[4]*Player{nil, nil, nil}, false},
		{[4]*Player{{Id: "player1"}, {Id: "player2"}, nil}, true},
		{[4]*Player{nil, nil, {Id: "player3"}}, true},
	}

	for _, tc := range testCases {
		game := Game{Players: tc.players}
		result := game.HasPlayer()
		if result != tc.hasPlayer {
			t.Errorf("Game.HasPlayer() = %v, want %v", result, tc.hasPlayer)
		}
	}
}

func TestGame_GetNextIndex(t *testing.T) {
	testCases := []struct {
		players   [4]*Player
		nextIndex int
	}{
		{[4]*Player{nil, nil, nil}, 0},
		{[4]*Player{{Id: "player1"}, nil, nil}, 1},
		{[4]*Player{{Id: "player1"}, {Id: "player2"}, nil}, 2},
		{[4]*Player{{Id: "player1"}, {Id: "player2"}, {Id: "player3"}}, 3},
		{[4]*Player{{Id: "player1"}, {Id: "player2"}, {Id: "player3"}, {Id: "player4"}}, 0},
	}

	for _, tc := range testCases {
		game := Game{Players: tc.players}
		result := game.GetNextIndex()
		if result != tc.nextIndex {
			t.Errorf("Game.GetNextIndex() = %v, want %v", result, tc.nextIndex)
		}
	}
}

func TestStartGame(t *testing.T) {
	game := StartGame()
	if game.Canvas == nil {
		t.Errorf("Expected game to have a canvas, but got nil")
	}
	if game.Canvas.Grid == nil {
		t.Errorf("Expected game to have a grid, but got nil")
	}
	if len(game.Players) != 4 {
		t.Errorf("Expected game to have 4 players, but got %d", len(game.Players))
	}
	for _, player := range game.Players {
		if player != nil {
			t.Errorf("Expected all players to be nil, but got %v", player)
		}
	}
}

func TestGame_ToJson(t *testing.T) {
	game := &Game{
		Canvas: &Canvas{
			Grid: Grid{
				{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}, Cell{X: 0, Y: 1, Data: &BrickData{Type: "Brick", Life: 2}}},
				{Cell{X: 1, Y: 0, Data: &BrickData{Type: "Empty", Life: 0}}, Cell{X: 1, Y: 1, Data: &BrickData{Type: "Brick", Life: 1}}},
			},
		},
		Players: [4]*Player{
			{Id: "player0",
				Paddle: &Paddle{X: 10, Y: 20, Width: 30, Height: 40},
				Balls: []*Ball{
					{X: 0, Y: 0, Index: 0},
					{X: 1, Y: 1, Index: 0},
					{X: 2, Y: 2, Index: 0},
				}},
			{
				Id:     "player1",
				Paddle: &Paddle{X: 15, Y: 25, Width: 35, Height: 45},
				Balls: []*Ball{
					{X: 3, Y: 3, Index: 1},
					{X: 4, Y: 4, Index: 1},
				}},
			nil,
			nil,
		},
	}
	gameBytes, err := json.Marshal(game)
	if err != nil {
		t.Errorf("Error marshalling game: %v", err)
	}

	result := game.ToJson()

	if string(result) != string(gameBytes) {
		t.Errorf("Expected %s, got %s", string(gameBytes), string(result))
	}
}

func TestGame_SubscribeBall(t *testing.T) {
	// create a game and a player
	game := StartGame()
	_, player := game.SubscribePlayer()

	// Create a test case for each ball in player
	for i, ball := range player.Balls {
		testCases := []struct {
			playerIndex int
			shouldBreak bool
		}{
			{i, false},
			{i + 1, true},
		}

		for _, tc := range testCases {
			// set the player index and break flag
			ball.Index = tc.playerIndex
			breakFlag := false

			// override the function to check if it breaks as expected
			game.SubscribeBall(ball)
			go func() {
				time.Sleep(time.Millisecond * 10)
				if game.Players[ball.Index] == nil && !breakFlag {
					breakFlag = true
				}
			}()
			time.Sleep(time.Millisecond * 50)
			if breakFlag != tc.shouldBreak {
				t.Errorf("Expected SubscribeBall to break %v but got %v for player index %d", tc.shouldBreak, breakFlag, tc.playerIndex)
			}
		}
	}
}

func TestGame_SubscribePaddle(t *testing.T) {
	game := StartGame()
	paddle := &Paddle{X: 10, Y: 20, Width: 30, Height: 40, Velocity: 5, Index: 3}
	game.SubscribePaddle(paddle)

	// Test case when player is connected
	if paddle.X != 10 || paddle.Y != 20 {
		t.Errorf("Expected paddle to remain at (10, 20) but got (%d, %d)", paddle.X, paddle.Y)
	}

	// Test case when player is disconnected
	game.Players[3] = nil
	time.Sleep(utils.Period)
	if paddle.X != 10 || paddle.Y != 20 {
		t.Errorf("Expected paddle to remain at (10, 20) after player disconnected, but got (%d, %d)", paddle.X, paddle.Y)
	}
}

func TestGame_SubscribePlayer(t *testing.T) {
	game := StartGame()
	playerCount := 0
	for i := 0; i < 4; i++ {
		unsubscribe, _ := game.SubscribePlayer()
		playerCount++
		if game.GetNextIndex() != playerCount {
			t.Errorf("Expected next index to be %d but got %d", playerCount, game.GetNextIndex())
		}
		if game.HasPlayer() != true {
			t.Errorf("Expected game to have a player but got %v", game.HasPlayer())
		}
		unsubscribe()
		playerCount--
		if game.GetNextIndex() != playerCount {
			t.Errorf("Expected next index to be %d but got %d", playerCount, game.GetNextIndex())
		}
	}
	if game.HasPlayer() != false {
		t.Errorf("Expected game to have no players but got %v", game.HasPlayer())
	}
}

func TestGame_UnSubscribePlayer(t *testing.T) {
	game := StartGame()
	player := NewPlayer(game.Canvas, 0, "player0")
	game.Players[0] = player
	game.UnSubscribePlayer(0)
	if game.Players[0] != nil {
		t.Errorf("Expected player to be unsubscribed but got %v", game.Players[0])
	}
	if player.Balls != nil {
		t.Errorf("Expected player balls to be set to nil but got %v", player.Balls)
	}
	if player.Paddle != nil {
		t.Errorf("Expected player paddle to be set to nil but got %v", player.Paddle)
	}
}
package game

type BrickData struct {
	Type string `json:"type"`
	Life int    `json:"life"`
}
type Cell struct {
	X    int        `json:"x"`
	Y    int        `json:"y"`
	Data *BrickData `json:"data"`
}

func NewCell(x, y, life int, typeOfCell string) Cell {
	return Cell{X: x, Y: y, Data: NewBrickData(typeOfCell, life)}
}

func NewBrickData(typeOfCell string, life int) *BrickData {
	if typeOfCell == "Brick" && life == 0 {
		life = 1
	}
	if typeOfCell == "Empty" {
		life = 0
	}
	return &BrickData{Type: typeOfCell, Life: life}
}

func (cell *Cell) Compare(comparedCell Cell) bool {
	if cell.Data.Type != comparedCell.Data.Type {
		return false
	}
	if cell.Data.Life != comparedCell.Data.Life {
		return false
	}
	return true
}

func (data *BrickData) Compare(comparedData *BrickData) bool {
	if data.Type != comparedData.Type {
		return false
	}
	if data.Life != comparedData.Life {
		return false
	}
	return true
}
package game

import (
	"github.com/lguibr/pongo/utils"
)

type Player struct {
	Index  int     `json:"index"`
	Id     string  `json:"id"`
	Canvas *Canvas `json:"canvas"`
	Color  [3]int  `json:"color"`
	Paddle *Paddle `json:"paddle"`
	Balls  []*Ball `json:"balls"`
}

func NewPlayer(canvas *Canvas, index int, id string) *Player {

	return &Player{
		Index:  index,
		Id:     id,
		Canvas: canvas,
		Color:  utils.NewRandomColor(),
		Paddle: NewPaddle(canvas, index),
		Balls: []*Ball{
			NewBall(canvas, 0, 0, 0, index),
		},
	}
}
package game

import (
	"fmt"
	"math"
	"math/rand"

	"github.com/lguibr/pongo/utils"
)

type Ball struct {
	X      int     `json:"x"`
	Y      int     `json:"y"`
	Vx     int     `json:"vx"`
	Vy     int     `json:"vy"`
	Ax     int     `json:"ax"`
	Ay     int     `json:"ay"`
	Radius int     `json:"radius"`
	Canvas *Canvas `json:"canvas"`
	Index  int     `json:"index"`
}

func NewBall(canvas *Canvas, x, y, radius, index int) *Ball {

	if x == 0 && y == 0 {
		cardinalPosition := [2]int{utils.CanvasSize/2 - utils.CellSize*1.5, 0}

		rotateX, rotateY := utils.RotateVector(
			index,
			cardinalPosition[0],
			cardinalPosition[1],
			utils.CanvasSize,
			utils.CanvasSize,
		)

		translatedVector := utils.SumVectors(
			[2]int{rotateX, rotateY},
			[2]int{utils.CanvasSize / 2, utils.CanvasSize / 2},
		)

		x, y = translatedVector[0], translatedVector[1]
	}

	if radius == 0 {
		radius = utils.BallSize
	}

	maxVelocity := utils.MaxVelocity
	minVelocity := utils.MinVelocity

	cardinalVX := minVelocity + rand.Intn(maxVelocity-minVelocity)
	cardinalVY := utils.RandomNumberN(maxVelocity)

	vx, vy := utils.RotateVector(index, -cardinalVX, cardinalVY, 1, 1)

	return &Ball{
		X:      x,
		Y:      y,
		Vx:     vx,
		Vy:     vy,
		Radius: radius,
		Canvas: canvas,
		Index:  index,
	}
}

func (ball *Ball) Move() {

	ball.X += ball.Vx + ball.Ax/2
	ball.Y += ball.Vy + ball.Ay/2

	ball.Vx += ball.Ax
	ball.Vy += ball.Ay

}

func (ball *Ball) CollidePaddle(paddle *Paddle) {

	collisionDetected := ball.BallInterceptPaddles(paddle)

	if collisionDetected {
		handlers := [4]func(){
			ball.HandleCollideRight,
			ball.HandleCollideTop,
			ball.HandleCollideLeft,
			ball.HandleCollideBottom,
		}

		handlerCollision := handlers[paddle.Index]
		handlerCollision()
	}
}

func (ball *Ball) CollideCells() {

	row, col := ball.getCenterIndex(ball.Canvas.Grid)

	if row < 0 || row > ball.Canvas.GridSize-1 || col < 0 || col > ball.Canvas.GridSize-1 {
		return
	}

	for i := -1; i <= 1; i++ {
		for j := -1; j <= 1; j++ {
			surroundingRow, surroundingCol := row+i, col+j

			if surroundingRow < 0 || surroundingRow > ball.Canvas.GridSize-1 || surroundingCol < 0 || surroundingCol > ball.Canvas.GridSize-1 {
				continue
			}

			ballInterceptsCell := ball.InterceptsIndex(surroundingRow, surroundingCol)

			if ballInterceptsCell {
				t := ball.Canvas.Grid[surroundingRow][surroundingCol].Data.Type
				if t == utils.CellTypes["Brick"] {
					ball.handleCollideBrick([2]int{row, col}, [2]int{surroundingRow, surroundingCol})
				}
				if t == utils.CellTypes["Block"] {
					ball.handleCollideBlock([2]int{row, col}, [2]int{surroundingRow, surroundingCol})
				}
			}
		}
	}
}

func (ball *Ball) CollideWalls() {
	if ball.CollidesBottomWall() {
		fmt.Println("Collide bottom wall")
		ball.HandleCollideBottom()
	}
	if ball.CollidesLeftWall() {
		fmt.Println("Collide left wall")
		ball.HandleCollideLeft()
	}
	if ball.CollidesTopWall() {
		fmt.Println("Collide top wall")
		ball.HandleCollideTop()
	}

	if ball.CollidesRightWall() {
		fmt.Println("Collide right wall")
		ball.HandleCollideRight()
	}
}

func (ball *Ball) CollidePaddles(players [4]*Player) {
	for _, player := range players {
		if player == nil {
			continue
		}
		ball.CollidePaddle(player.Paddle)
	}
}

func (ball *Ball) handleCollideBrick(oldIndices, newIndices [2]int) {
	ball.handleCollideBlock(oldIndices, newIndices)
	ball.Canvas.Grid[newIndices[0]][newIndices[1]].Data.Life -= 1
	if ball.Canvas.Grid[newIndices[0]][newIndices[1]].Data.Life == 0 {
		ball.Canvas.Grid[newIndices[0]][newIndices[1]].Data.Type = utils.CellTypes["Empty"]
	}
}

func (ball *Ball) handleCollideBlock(oldIndices, newIndices [2]int) {
	velocityReflector := utils.SubtractVectors(oldIndices, newIndices)

	if velocityReflector[0] != 0 {
		ball.Vx = -ball.Vx
	}
	if velocityReflector[1] != 0 {
		ball.Vy = -ball.Vy
	}

}

func (ball *Ball) getCenterIndex(grid Grid) (x, y int) {
	cellSize := utils.CellSize
	row := ball.X / cellSize
	col := ball.Y / cellSize
	return row, col
}

func (ball *Ball) HandleCollideRight() {
	ball.Vx = -utils.Abs(ball.Vx)
}

func (ball *Ball) HandleCollideLeft() {
	ball.Vx = utils.Abs(ball.Vx)
}

func (ball *Ball) HandleCollideTop() {
	ball.Vy = utils.Abs(ball.Vy)
}

func (ball *Ball) HandleCollideBottom() {
	ball.Vy = -utils.Abs(ball.Vy)
}

func (ball *Ball) CollidesTopWall() bool {
	return ball.Y-ball.Radius <= 0
}

func (ball *Ball) CollidesBottomWall() bool {
	return ball.Y+ball.Radius >= ball.Canvas.Height
}

func (ball *Ball) CollidesRightWall() bool {
	return ball.X+ball.Radius >= ball.Canvas.Width
}

func (ball *Ball) CollidesLeftWall() bool {
	return ball.X-ball.Radius <= 0
}

func (ball *Ball) InterceptsIndex(x, y int) bool {
	cellSize := ball.Canvas.CellSize

	leftTopX := x * cellSize
	leftTopY := y * cellSize

	bottomRightX := leftTopX + cellSize
	bottomRightY := leftTopY + cellSize

	if ball.X > leftTopX &&
		ball.X < bottomRightX &&
		ball.Y > leftTopY &&
		ball.Y < bottomRightY {
		return true
	}

	closestX := math.Min(
		math.Max(float64(ball.X), float64(leftTopX)),
		float64(bottomRightX),
	)

	closestY := math.Min(
		math.Max(float64(ball.Y), float64(leftTopY)),
		float64(bottomRightY),
	)

	distance := utils.Distance(
		ball.X,
		ball.Y,
		int(closestX),
		int(closestY),
	)

	return distance < float64(ball.Radius)
}

func (ball *Ball) BallInterceptPaddles(paddle *Paddle) bool {

	paddleTopLeftX := paddle.X
	paddleTopLeftY := paddle.Y

	paddleBottomRightX := paddleTopLeftX + paddle.Width
	paddleBottomRightY := paddleTopLeftY + paddle.Height

	if ball.X > paddleTopLeftX &&
		ball.X < paddleBottomRightX &&
		ball.Y > paddleTopLeftY &&
		ball.Y < paddleBottomRightY {
		return true
	}

	closestX := math.Min(
		math.Max(float64(ball.X), float64(paddleTopLeftX)),
		float64(paddleBottomRightX),
	)

	closestY := math.Min(
		math.Max(float64(ball.Y), float64(paddleTopLeftY)),
		float64(paddleBottomRightY),
	)

	distance := utils.Distance(
		ball.X,
		ball.Y,
		int(closestX),
		int(closestY),
	)

	return distance < float64(ball.Radius)
}
package game

import (
	"testing"

	"github.com/lguibr/pongo/utils"
)

func TestPaddle_SetDirection(t *testing.T) {
	paddle := Paddle{}
	testCases := []struct {
		buffer     []byte
		direction  string
		shouldPass bool
	}{
		{[]byte(`{"direction": "ArrowLeft"}`), "left", true},
		{[]byte(`{"direction": "ArrowRight"}`), "right", true},
		{[]byte(`{"direction": "invalid"}`), "", false},
		{[]byte(`{}`), "", false},
		{[]byte(``), "", false},
	}
	for _, tc := range testCases {
		paddle.SetDirection(tc.buffer)
		if tc.shouldPass {
			if paddle.Direction != tc.direction {
				t.Errorf("Expected direction to be %s but got %s", tc.direction, paddle.Direction)
			}
		} else {
			if paddle.Direction != "" {
				t.Errorf("Expected direction to be empty but got %s", paddle.Direction)
			}
		}
	}
}

func TestPaddle_Move(t *testing.T) {
	paddle := Paddle{X: 10, Y: 20, Width: 30, Height: 40, Velocity: 5, Index: 3}
	testCases := []struct {
		index      int
		direction  string
		finalX     int
		finalY     int
		shouldMove bool
	}{
		{3, "left", 5, 20, true},
		{3, "right", 10, 20, true},
		{3, "", 10, 20, false},
		{3, "up", 10, 20, false},
		{3, "down", 10, 20, false},
		{3, "invalid", 10, 20, false},
		{2, "right", 10, 25, true},
		{3, "left", 5, 25, true},
	}

	for _, tc := range testCases {
		paddle.Index = tc.index
		paddle.Direction = tc.direction
		paddle.Move()
		if tc.shouldMove {
			if paddle.X != tc.finalX || paddle.Y != tc.finalY {
				t.Errorf("Expected paddle to move to (%d, %d) but got (%d, %d)", tc.finalX, tc.finalY, paddle.X, paddle.Y)
			}
		} else {
			if paddle.X != 10 || paddle.Y != 20 {
				t.Errorf("Expected paddle to remain at (10, 20) but got (%d, %d)", paddle.X, paddle.Y)
			}
		}
	}

	// test case when paddle is at the boundary
	paddle.X = utils.CanvasSize - paddle.Width
	paddle.Y = utils.CanvasSize - paddle.Height
	paddle.Direction = "right"
	paddle.Move()
	if paddle.X != utils.CanvasSize-paddle.Width || paddle.Y != utils.CanvasSize-paddle.Height {
		t.Errorf("Expected paddle to remain at (%d, %d) but got (%d, %d)", utils.CanvasSize-paddle.Width, utils.CanvasSize-paddle.Height, paddle.X, paddle.Y)
	}
}
package game

import (
	"encoding/json"
	"fmt"

	"github.com/lguibr/pongo/utils"
)

type Paddle struct {
	X         int     `json:"x"`
	Y         int     `json:"y"`
	Width     int     `json:"width"`
	Height    int     `json:"height"`
	Index     int     `json:"index"`
	Direction string  `json:"direction"`
	Velocity  int     `json:"velocity"`
	Canvas    *Canvas `json:"canvas"`
}

func (paddle *Paddle) Move() {
	if paddle.Direction != "left" && paddle.Direction != "right" {
		return
	}

	velocity := [2]int{0, paddle.Velocity}

	if paddle.Index%2 != 0 {
		velocity = utils.SwapVectorCoordinates(velocity)
	}

	velocityX, velocityY := velocity[0], velocity[1]
	if paddle.Direction == "left" {

		if paddle.X-velocityX < 0 || paddle.Y+velocityY < 0 {
			return
		}

		paddle.X -= velocityX
		paddle.Y -= velocityY
	} else {

		if paddle.X+paddle.Width+velocityX > utils.CanvasSize || paddle.Y+paddle.Height-velocityY > utils.CanvasSize {
			return
		}

		paddle.X += velocityX
		paddle.Y += velocityY
	}

}

func NewPaddle(canvas *Canvas, index int) *Paddle {

	offSet := -utils.PaddleLength/2 + utils.PaddleWeight/2
	if index > 1 {
		offSet = -offSet
	}

	cardinalPosition := [2]int{utils.CanvasSize/2 - utils.PaddleWeight/2, offSet}
	rotateX, rotateY := utils.RotateVector(index, cardinalPosition[0], cardinalPosition[1], utils.CanvasSize, utils.CanvasSize)
	translatedVector := utils.SumVectors([2]int{rotateX, rotateY}, [2]int{utils.CanvasSize/2 - utils.PaddleWeight/2, utils.CanvasSize/2 - utils.PaddleWeight/2})
	x, y := translatedVector[0], translatedVector[1]

	indexOdd := index % 2
	var width, height int

	if indexOdd == 0 {
		height = utils.PaddleLength
		width = utils.PaddleWeight
	} else {
		width = utils.PaddleLength
		height = utils.PaddleWeight
	}

	return &Paddle{
		X:         x,
		Y:         y,
		Index:     index,
		Width:     width,
		Height:    height,
		Direction: "",
		Velocity:  utils.MinVelocity * 2,
		Canvas:    canvas,
	}
}

type Direction struct {
	Direction string `json:"direction"`
}

func (paddle *Paddle) SetDirection(buffer []byte) {
	direction := Direction{}
	err := json.Unmarshal(buffer, &direction)
	if err != nil {
		fmt.Println("Error unmarshalling message:", err)
	}
	newDirection := utils.DirectionFromString(direction.Direction)
	paddle.Direction = newDirection
}
package game

import (
	"github.com/lguibr/pongo/utils"
)

type Grid [][]Cell

func (grid Grid) LineIntersectedCellIndices(cellSize int, line [2][2]int) [][2]int {
	var intersects [][2]int
	for i := range grid {
		for j := range grid[i] {
			if line[0][0] <= i && i <= line[1][0] && line[0][1] <= j && j <= line[1][1] {
				intersects = append(intersects, [2]int{i, j})
			}
		}
	}
	return intersects
}

func NewGrid(gridSize int) Grid {
	grid := make(Grid, gridSize)
	for i := range grid {
		grid[i] = make([]Cell, gridSize)
	}

	for i, row := range grid {
		for j := range row {
			data := &BrickData{Type: "Empty", Life: 0}
			grid[i][j] = Cell{X: i, Y: j, Data: data}
		}
	}
	return grid
}

func (grid Grid) CreateQuarterGridSeed(numberOfVectors, maxVectorSize int) {
	vectorZero := [2]int{0, 0}
	randomVectors := utils.NewRandomPositiveVectors(numberOfVectors, maxVectorSize)

	randomLines := [][2][2]int{}
	for _, vector := range randomVectors {
		randomLines = append(randomLines, [2][2]int{vectorZero, vector})
	}

	indexes := [][2]int{}
	for _, line := range randomLines {
		indexes = append(indexes, grid.LineIntersectedCellIndices(utils.CellSize, line)...)
	}

	for _, index := range indexes {
		if grid[index[0]][index[1]].Data.Type == "Brick" {
			grid[index[0]][index[1]].Data.Life = grid[index[0]][index[1]].Data.Life + 1
			continue
		}

		grid[index[0]][index[1]] = Cell{
			X: index[0],
			Y: index[1],
			Data: &BrickData{
				Type: "Brick",
				Life: 1,
			},
		}

	}

}

func (grid Grid) FillGridWithQuarterGrids(q1, q2, q3, q4 Grid) {

	if len(q1) != len(q2) || len(q1) != len(q3) || len(q1) != len(q4) || len(q1) == 0 {
		panic("Grids must be of the same size")
	}
	if len(grid) != 2*len(q1) || len(grid) == 0 {
		panic("Grid must be twice the size of the quarter grids")
	}

	n := len(grid)
	m := len(grid[0])

	for i := 0; i < n/2; i++ {

		for j := 0; j < m/2; j++ {

			//INFO Filling quarter one of the grid
			grid[i][j] = q1[i][j]
			grid[i][j].X = i //INFO Fixing the X value
			grid[i][j].Y = j //INFO Fixing the Y value

			//INFO Filling quarter two of the grid
			grid[i][m-1-j] = q2[i][j]
			grid[i][m-1-j].X = i
			grid[i][m-1-j].Y = m - 1 - j

			//INFO Filling quarter three of the grid
			grid[n-1-i][j] = q3[i][j]
			grid[n-1-i][j].X = n - 1 - i
			grid[n-1-i][j].Y = j

			//INFO Filling quarter four of the grid
			grid[n-1-i][m-1-j] = q4[i][j]
			grid[n-1-i][m-1-j].X = n - 1 - i
			grid[n-1-i][m-1-j].Y = m - 1 - j

		}

	}
}

func (grid Grid) Rotate() Grid {
	result := make([][]Cell, len(grid[0]))
	for i := range result {
		result[i] = make([]Cell, len(grid))
	}
	for i, row := range grid {
		for j, cell := range row {
			result[j][len(grid)-i-1] = cell
		}
	}
	return result
}

func (grid Grid) RandomWalker(numberOfSteps int) {
	gridSize := len(grid)
	startPoint := [2]int{gridSize / 2, gridSize / 2}
	grid[startPoint[0]][startPoint[1]].Data.Type = "Brick"
	grid[startPoint[0]][startPoint[1]].Data.Life = 1
	var getNextPoint func(currentPoint [2]int) [2]int
	getNextPoint = func(currentPoint [2]int) [2]int {

		nextPoint := [2]int{currentPoint[0] + utils.RandomNumber(2), currentPoint[1] + utils.RandomNumber(2)}

		if nextPoint[0] < 0 || nextPoint[0] > gridSize || nextPoint[1] < 0 || nextPoint[1] > gridSize {
			return getNextPoint(currentPoint)
		}
		return nextPoint
	}

	stepsResting := numberOfSteps - 1

	for i := 0; i < stepsResting; i++ {
		nextPoint := getNextPoint(startPoint)
		nextCell := grid[nextPoint[0]][nextPoint[1]]
		if nextCell.Data.Type == "Brick" {
			nextCell.Data.Life++
		} else {
			nextCell.Data.Type = "Brick"
			nextCell.Data.Life = 1
		}
	}
}

func (grid Grid) Compare(comparedGrid Grid) bool {
	if len(grid) != len(comparedGrid) {
		return false
	}
	for i := range grid {
		if len(grid[i]) != len(comparedGrid[i]) {
			return false
		}
		for j := range grid[i] {
			match := grid[i][j].Compare(comparedGrid[i][j])
			if !match {
				return false
			}
		}
	}
	return true
}

func (grid Grid) Fill(numberOfVectors, maxVectorSize, randomWalkers, randomSteps int) {

	if numberOfVectors == 0 {
		numberOfVectors = utils.NumberOfVectors
	}
	if maxVectorSize == 0 {
		maxVectorSize = utils.MaxVectorSize
	}
	if randomWalkers == 0 {
		randomWalkers = utils.NumberOfRandomWalkers
	}
	if randomSteps == 0 {
		randomSteps = utils.NumberOfRandomSteps
	}

	gridSize := len(grid)
	halfGridSize := gridSize / 2

	quarters := [4]Grid{}

	for i := 0; i < 4; i++ {

		gridSeed := NewGrid(halfGridSize)
		gridSeed.CreateQuarterGridSeed(numberOfVectors, maxVectorSize)
		for j := 0; j < randomWalkers; j++ {
			gridSeed.RandomWalker(randomSteps)
		}
		quarters[i] = gridSeed.Rotate().Rotate()

	}

	grid.FillGridWithQuarterGrids(
		quarters[0],
		quarters[1],
		quarters[2],
		quarters[3],
	)

}
package game

import (
	"testing"

	"github.com/lguibr/pongo/utils"
)

func TestBall_BallInterceptPaddles(t *testing.T) {
	ball := &Ball{X: 100, Y: 100, Radius: 10}
	testCases := []struct {
		paddle     *Paddle
		intercepts bool
	}{
		{&Paddle{X: 90, Y: 90, Width: 20, Height: 20}, true},
		{&Paddle{X: 110, Y: 110, Width: 20, Height: 20}, false},
		{&Paddle{X: 90, Y: 110, Width: 20, Height: 20}, false},
		{&Paddle{X: 110, Y: 90, Width: 20, Height: 20}, false},
		{&Paddle{X: 80, Y: 80, Width: 20, Height: 20}, true},
		{&Paddle{X: 120, Y: 120, Width: 20, Height: 20}, false},
	}

	for index, tc := range testCases {
		result := ball.BallInterceptPaddles(tc.paddle)
		if result != tc.intercepts {
			t.Errorf("Expected BallInterceptPaddles to return %t but got %t in test case index %d", tc.intercepts, result, index)
		}
	}
}

func TestBall_InterceptsIndex(t *testing.T) {
	tests := []struct {
		name string
		ball *Ball
		x, y int
		want bool
	}{
		{
			name: "Intercepts top-left corner",
			ball: &Ball{X: 25, Y: 25, Radius: 10, Canvas: &Canvas{CellSize: 50}},
			x:    0, y: 0,
			want: true,
		},
		{
			name: "Does not intercept top-left corner",
			ball: &Ball{X: 25, Y: 25, Radius: 5, Canvas: &Canvas{CellSize: 10}},
			x:    0, y: 0,
			want: false,
		},
		{
			name: "Intercepts center of cell",
			ball: &Ball{X: 75, Y: 75, Radius: 10, Canvas: &Canvas{CellSize: 50}},
			x:    1, y: 1,
			want: true,
		},
		{
			name: "Intercepts bottom-right corner",
			ball: &Ball{X: 75, Y: 75, Radius: 10, Canvas: &Canvas{CellSize: 50}},
			x:    1, y: 1,
			want: true,
		},
		{
			name: "Does not intercept bottom-right corner",
			ball: &Ball{X: 75, Y: 75, Radius: 5, Canvas: &Canvas{CellSize: 50}},
			x:    0, y: 0,
			want: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := tt.ball.InterceptsIndex(tt.x, tt.y); got != tt.want {
				t.Errorf("InterceptsIndex() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestBall_CollidesLeftWall(t *testing.T) {
	testCases := []struct {
		name              string
		ballX             int
		ballRadius        int
		expectedCollision bool
	}{
		{"ball is inside the wall", 10, 5, false},
		{"ball touches the left wall", 5, 5, true},
		{"ball is on the left wall", 0, 5, true},
		{"ball is outside of the left wall", -5, 5, true},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			ball := &Ball{X: tc.ballX, Radius: tc.ballRadius}
			if collision := ball.CollidesLeftWall(); collision != tc.expectedCollision {
				t.Errorf("Expected collision to be %t but got %t for ballX = %d, ballRadius = %d", tc.expectedCollision, collision, tc.ballX, tc.ballRadius)
			}
		})
	}
}

func TestBall_CollideRightWall(t *testing.T) {
	type CollideRightWallTestCase struct {
		name     string
		ball     Ball
		expected bool
	}
	testCases := []CollideRightWallTestCase{
		{
			name:     "ball just touches the right wall",
			ball:     Ball{X: 900, Radius: 10, Canvas: &Canvas{Width: 900}},
			expected: true,
		},
		{
			name:     "ball is still inside the canvas",
			ball:     Ball{X: 800, Radius: 10, Canvas: &Canvas{Width: 900}},
			expected: false,
		},
		{
			name:     "ball exceeds the right wall",
			ball:     Ball{X: 905, Radius: 10, Canvas: &Canvas{Width: 900}},
			expected: true,
		},
	}
	for _, testCase := range testCases {
		t.Run(testCase.name, func(t *testing.T) {
			result := testCase.ball.CollidesRightWall()
			if result != testCase.expected {
				t.Errorf("For test case %s expected %v but got %v", testCase.name, testCase.expected, result)
			}
		})
	}
}

func TestBall_CollidesBottomWall(t *testing.T) {
	testCases := []struct {
		name              string
		ballY             int
		ballRadius        int
		canvasHeight      int
		expectedCollision bool
	}{
		{
			name:              "ball with bottom edge outside canvas",
			ballY:             10,
			ballRadius:        5,
			canvasHeight:      15,
			expectedCollision: true,
		},
		{
			name:              "ball with bottom edge inside canvas",
			ballY:             5,
			ballRadius:        5,
			canvasHeight:      15,
			expectedCollision: false,
		},
		{
			name:              "ball with top edge outside canvas",
			ballY:             -5,
			ballRadius:        5,
			canvasHeight:      15,
			expectedCollision: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			ball := &Ball{Y: tc.ballY, Radius: tc.ballRadius, Canvas: &Canvas{Height: tc.canvasHeight}}
			if collision := ball.CollidesBottomWall(); collision != tc.expectedCollision {
				t.Errorf("Expected collision to be %t but got %t for ballY = %d, ballRadius = %d, canvasHeight = %d", tc.expectedCollision, collision, tc.ballY, tc.ballRadius, tc.canvasHeight)
			}
		})
	}
}

func TestBall_CollidesTopWall(t *testing.T) {
	testCases := []struct {
		name              string
		ballY             int
		ballRadius        int
		expectedCollision bool
	}{
		{"ball above top wall", 10, 5, false},
		{"ball at top wall", 5, 5, true},
		{"ball at 0", 0, 5, true},
		{"ball inside top wall", -5, 5, true},
	}

	for _, tc := range testCases {
		ball := &Ball{Y: tc.ballY, Radius: tc.ballRadius}
		if collision := ball.CollidesTopWall(); collision != tc.expectedCollision {
			t.Errorf("Test case %s: Expected collision to be %t but got %t for ballY = %d, ballRadius = %d", tc.name, tc.expectedCollision, collision, tc.ballY, tc.ballRadius)
		}
	}
}

func TestBall_HandleCollideBottom(t *testing.T) {
	testCases := []struct {
		name       string
		ballVy     int
		expectedVy int
	}{
		//INFO VY Should always be negative after bottom collision
		{"vy is positive", 5, -5},
		{"vy is negative", -5, -5},
		{"vy is zero", 0, 0},
	}
	for _, tc := range testCases {
		ball := &Ball{Vy: tc.ballVy}
		ball.HandleCollideBottom()
		if ball.Vy != tc.expectedVy {
			t.Errorf("Test case: %s. Expected Vy: %d, got: %d", tc.name, tc.expectedVy, ball.Vy)
		}
	}
}

func TestBall_HandleCollideTop(t *testing.T) {
	testCases := []struct {
		name       string
		ballVy     int
		expectedVy int
	}{
		//INFO VY Should always be positive after bottom collision
		{"vy is positive", 5, 5},
		{"vy is negative", -5, 5},
		{"vy is zero", 0, 0},
	}
	for _, tc := range testCases {
		ball := &Ball{Vy: tc.ballVy}
		ball.HandleCollideTop()
		if ball.Vy != tc.expectedVy {
			t.Errorf("Test case: %s. Expected Vy: %d, got: %d", tc.name, tc.expectedVy, ball.Vy)
		}
	}
}

func TestBall_HandleCollideLeft(t *testing.T) {
	testCases := []struct {
		name                string
		ballVx              int
		expectedCollisionVx int
	}{
		//INFO VX Should always be positive after bottom collision
		{name: "negative vx", ballVx: -10, expectedCollisionVx: 10},
		{name: "positive vx", ballVx: 10, expectedCollisionVx: 10},
		{name: "zero vx", ballVx: 0, expectedCollisionVx: 0},
	}

	for _, tc := range testCases {
		ball := &Ball{Vx: tc.ballVx}
		ball.HandleCollideLeft()
		if ball.Vx != tc.expectedCollisionVx {
			t.Errorf("Test case %s failed: expected Vx to be %d but got %d", tc.name, tc.expectedCollisionVx, ball.Vx)
		}
	}
}

func TestBall_HandleCollideRight(t *testing.T) {
	testCases := []struct {
		name                string
		ballVx              int
		expectedCollisionVx int
	}{
		//INFO VX Should always be negative after bottom collision
		{name: "negative vx", ballVx: -10, expectedCollisionVx: -10},
		{name: "positive vx", ballVx: 10, expectedCollisionVx: -10},
		{name: "zero vx", ballVx: 0, expectedCollisionVx: 0},
	}

	for _, tc := range testCases {
		ball := &Ball{Vx: tc.ballVx}
		ball.HandleCollideRight()
		if ball.Vx != tc.expectedCollisionVx {
			t.Errorf("Test case %s failed: expected Vx to be %d but got %d", tc.name, tc.expectedCollisionVx, ball.Vx)
		}
	}
}

func TestBall_GetCenterIndex(t *testing.T) {

	cellSize := 10
	gridSize := 50

	testCases := []struct {
		name        string
		ballX       int
		ballY       int
		expectedRow int
		expectedCol int
	}{

		{
			name:        "center of cell",
			ballX:       cellSize / 2,
			ballY:       cellSize / 2,
			expectedRow: 0,
			expectedCol: 0,
		},
		{
			name:        "bottom right of cell",
			ballX:       cellSize - 1,
			ballY:       cellSize - 1,
			expectedRow: 0,
			expectedCol: 0,
		},
		{
			name:        "top left of cell",
			ballX:       0,
			ballY:       0,
			expectedRow: 0,
			expectedCol: 0,
		},
		{
			name:        "center of grid",
			ballX:       cellSize * gridSize / 2,
			ballY:       cellSize * gridSize / 2,
			expectedRow: gridSize / cellSize,
			expectedCol: gridSize / cellSize,
		},
	}

	for _, tc := range testCases {
		ball := &Ball{X: tc.ballX, Y: tc.ballY}
		row, col := ball.getCenterIndex(NewGrid(gridSize))
		if row != tc.expectedRow || col != tc.expectedCol {
			t.Errorf("Test case %s failed: expected row %d and col %d but got row %d and col %d", tc.name, tc.expectedRow, tc.expectedCol, row, col)
		}
	}
}

func TestBall_HandleCollideBlock(t *testing.T) {
	testCases := []struct {
		name       string
		oldIndices [2]int
		newIndices [2]int
		expectedVx int
		expectedVy int
	}{
		{
			name:       "Collision Top Down",
			oldIndices: [2]int{1, 2},
			newIndices: [2]int{1, 3},
			expectedVx: 1,
			expectedVy: -1,
		},
		{
			name:       "Collision Left Right",
			oldIndices: [2]int{2, 1},
			newIndices: [2]int{1, 1},
			expectedVx: -1,
			expectedVy: 1,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			ball := &Ball{Vx: 1, Vy: 1}
			ball.handleCollideBlock(tc.oldIndices, tc.newIndices)
			if ball.Vx != tc.expectedVx || ball.Vy != tc.expectedVy {
				t.Errorf("Expected Vx = %d, Vy = %d but got Vx = %d, Vy = %d for oldIndices = %v, newIndices = %v",
					tc.expectedVx,
					tc.expectedVy,
					ball.Vx,
					ball.Vy,
					tc.oldIndices,
					tc.newIndices,
				)
			}
		})
	}
}

func TestBall_HandleCollideBrick(t *testing.T) {
	testCases := []struct {
		name         string
		oldIndices   [2]int
		newIndices   [2]int
		life         int
		expectedVx   int
		expectedVy   int
		expectedLife int
		expectedType string
	}{
		{
			name:         "collides with brick",
			oldIndices:   [2]int{1, 2},
			newIndices:   [2]int{1, 3},
			life:         5,
			expectedVx:   1,
			expectedVy:   -1,
			expectedLife: 4,
			expectedType: "Brick",
		},
		{
			name:         "collides with brick with life of 1",
			oldIndices:   [2]int{2, 1},
			newIndices:   [2]int{1, 1},
			life:         1,
			expectedVx:   -1,
			expectedVy:   1,
			expectedLife: 0,
			expectedType: "Empty",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {

			data := &Cell{Data: NewBrickData("Brick", tc.life)}
			grid := NewGrid(10)
			grid[tc.newIndices[0]][tc.newIndices[1]] = *data
			ball := &Ball{Vx: 1, Vy: 1, Canvas: &Canvas{Grid: grid}}

			ball.handleCollideBrick(tc.oldIndices, tc.newIndices)

			if ball.Vx != tc.expectedVx || ball.Vy != tc.expectedVy {
				t.Errorf("Expected Vx = %d, Vy = %d but got Vx = %d, Vy = %d for oldIndices = %v, newIndices = %v",
					tc.expectedVx,
					tc.expectedVy,
					ball.Vx,
					ball.Vy,
					tc.oldIndices,
					tc.newIndices,
				)
			}
			if ball.Canvas.Grid[tc.newIndices[0]][tc.newIndices[1]].Data.Life != tc.expectedLife {
				t.Errorf("Expected life = %d but got life = %d for oldIndices = %v, newIndices = %v",
					tc.expectedLife,
					ball.Canvas.Grid[tc.newIndices[0]][tc.newIndices[1]].Data.Life,
					tc.oldIndices,
					tc.newIndices,
				)
			}
			if ball.Canvas.Grid[tc.newIndices[0]][tc.newIndices[1]].Data.Type != tc.expectedType {
				t.Errorf("Expected type = %s but got type = %s for oldIndices = %v, newIndices = %v",
					tc.expectedType,
					ball.Canvas.Grid[tc.newIndices[0]][tc.newIndices[1]].Data.Type,
					tc.oldIndices,
					tc.newIndices,
				)
			}
		})
	}
}

func TestBall_CollidePaddles(t *testing.T) {
	// Create test cases with different scenarios
	testCases := []struct {
		name               string
		players            [4]*Player
		expectedCollision  bool
		expectedVelocityVx int
		expectedVelocityVy int
	}{
		{
			name: "Collision with first player's paddle",
			players: [4]*Player{
				{Paddle: &Paddle{X: 50, Y: 50, Width: 30, Height: 30}},
				nil,
				nil,
				nil,
			},
			expectedCollision:  true,
			expectedVelocityVx: -1,
			expectedVelocityVy: 1,
		},
		{
			name: "No collision with any paddle",
			players: [4]*Player{
				{Paddle: &Paddle{X: 100, Y: 100, Width: 30, Height: 30}},
				{Paddle: &Paddle{X: 200, Y: 200, Width: 30, Height: 30}},
				{Paddle: &Paddle{X: 300, Y: 300, Width: 30, Height: 30}},
				{Paddle: &Paddle{X: 400, Y: 400, Width: 30, Height: 30}},
			},
			expectedCollision:  false,
			expectedVelocityVx: 1,
			expectedVelocityVy: 1,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			ball := &Ball{X: 75, Y: 75, Vx: 1, Vy: 1, Radius: 10}

			ball.CollidePaddles(tc.players)
			if ball.Vx != tc.expectedVelocityVx || ball.Vy != tc.expectedVelocityVy {
				t.Errorf("Expected Vx = %d, Vy = %d but got Vx = %d, Vy = %d for players = %v",
					tc.expectedVelocityVx,
					tc.expectedVelocityVy,
					ball.Vx,
					ball.Vy,
					tc.players,
				)
			}
		})
	}
}

func TestBall_CollideWalls(t *testing.T) {
	testCases := []struct {
		name         string
		ballX        int
		ballY        int
		ballVx       int
		ballVy       int
		ballRadius   int
		canvasWidth  int
		canvasHeight int
		expectedVx   int
		expectedVy   int
	}{
		{
			name:         "Collide bottom wall",
			ballX:        75,
			ballY:        100,
			ballVx:       1,
			ballVy:       1,
			ballRadius:   10,
			canvasWidth:  100,
			canvasHeight: 100,
			expectedVx:   1,
			expectedVy:   -1,
		},
		{
			name:         "Collide top wall",
			ballX:        75,
			ballY:        10,
			ballVx:       1,
			ballVy:       -1,
			ballRadius:   10,
			canvasWidth:  100,
			canvasHeight: 100,
			expectedVx:   1,
			expectedVy:   1,
		},
		{
			name:         "Collide Right wall and top wall",
			ballX:        95,
			ballY:        10,
			ballVx:       1,
			ballVy:       -1,
			ballRadius:   10,
			canvasWidth:  100,
			canvasHeight: 100,
			expectedVx:   -1,
			expectedVy:   1,
		},
		{
			name:         "Collide All Walls, last collisions at Top and Right ",
			ballX:        50,
			ballY:        50,
			ballVx:       1,
			ballVy:       1,
			ballRadius:   60,
			canvasWidth:  100,
			canvasHeight: 100,
			expectedVx:   -1,
			expectedVy:   1,
		},
	}
	for _, test := range testCases {
		t.Run(test.name, func(t *testing.T) {

			ball := &Ball{
				X:      test.ballX,
				Y:      test.ballY,
				Radius: test.ballRadius,
				Vx:     test.ballVx,
				Vy:     test.ballVy,
				Canvas: &Canvas{Width: test.canvasWidth, Height: test.canvasHeight},
			}

			ball.CollideWalls()

			if ball.Vx != test.expectedVx || ball.Vy != test.expectedVy {
				t.Errorf("Test case %s: expected Vx = %d, Vy = %d but got Vx = %d, Vy = %d", test.name, test.expectedVx, test.expectedVy, ball.Vx, ball.Vy)
			}

		})
	}
}
func TestBall_Move(t *testing.T) {
	canvas := NewCanvas(utils.CanvasSize, utils.GridSize)
	ball := NewBall(canvas, 10, 20, 30, 1)
	ball.Ax = 1
	ball.Ay = 2
	testCases := []struct {
		name                                         string
		vx, vy, ax, ay                               int
		expectedX, expectedY, expectedVx, expectedVy int
	}{
		{"TestCase1",
			10, 20, 1, 2,
			20, 41, 11, 22,
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {

			ball.Vx = tc.vx
			ball.Vy = tc.vy
			ball.Ax = tc.ax
			ball.Ay = tc.ay
			ball.Move()

			if ball.X != tc.expectedX {
				t.Errorf("Expected X to be %d, but got %d", tc.expectedX, ball.X)
			}
			if ball.Y != tc.expectedY {
				t.Errorf("Expected Y to be %d, but got %d", tc.expectedY, ball.Y)
			}
			if ball.Vx != tc.expectedVx {
				t.Errorf("Expected Vx to be %d, but got %d", tc.expectedVx, ball.Vx)
			}
			if ball.Vy != tc.expectedVy {
				t.Errorf("Expected Vy to be %d, but got %d", tc.expectedVy, ball.Vy)
			}
		})
	}
}

func TestBall_CollidePaddle(t *testing.T) {
	canvas := NewCanvas(utils.CanvasSize, utils.GridSize)
	ball := NewBall(canvas, 10, 20, 30, 1)
	paddle := NewPaddle(canvas, 0)
	testCases := []struct {
		name                                        string
		ballX, ballY, ballVx, ballVy                int
		paddleX, paddleY, paddleWidth, paddleHeight int
		expectedVx, expectedVy                      int
	}{
		{
			"TestCase1",
			10, 20, 1, 1,
			10, 20, 30, 30,
			-1, 1,
		},
		{
			"TestCase2",
			10, 20, 1, 1,
			30, 30, 30, 30,
			-1, 1,
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			ball.X, ball.Y = tc.ballX, tc.ballY
			ball.Vx, ball.Vy = tc.ballVx, tc.ballVy
			paddle.X, paddle.Y, paddle.Width, paddle.Height = tc.paddleX, tc.paddleY, tc.paddleWidth, tc.paddleHeight
			ball.CollidePaddle(paddle)
			if ball.Vx != tc.expectedVx {
				t.Errorf("Expected Vx to be %d, but got %d", tc.expectedVx, ball.Vx)
			}
			if ball.Vy != tc.expectedVy {
				t.Errorf("Expected Vy to be %d, but got %d", tc.expectedVy, ball.Vy)
			}
		})
	}
}

func TestCollideCells(t *testing.T) {
	canvas := NewCanvas(12, 6)
	ball := NewBall(canvas, 10, 10, 30, 1)

	// Set up test cases
	testCases := []struct {
		name                  string
		ballX, ballY          int
		theType               string
		life                  int
		expectedCollisionType string
		expectedLife          int
	}{
		{
			"TestCase1",
			10, 20,
			"Brick",
			2,
			"Brick",
			1,
		},
		{
			"TestCase2",
			15, 25,
			"Block",
			0,
			"Block",
			0,
		},
		{
			"TestCase3",
			15, 25,
			"Empty",
			0,
			"Empty",
			0,
		},
	}

	// Override the grid of the canvas
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			ball.X, ball.Y = tc.ballX, tc.ballY
			grid := make(Grid, 10)
			for i := range grid {
				grid[i] = make([]Cell, 10)
				for j := range grid[i] {
					grid[i][j] = NewCell(i, j, tc.life, tc.theType)
				}
			}
			ball.Canvas.Grid = grid
			ball.CollideCells()
			if ball.Canvas.Grid[0][0].Data.Type != tc.expectedCollisionType {
				t.Errorf("Expected collision type to be %s, but got %s", tc.expectedCollisionType, ball.Canvas.Grid[0][0].Data.Type)
			}
			if ball.Canvas.Grid[0][0].Data.Life != tc.expectedLife {
				t.Errorf("Expected life to be %d, but got %d", tc.expectedLife, ball.Canvas.Grid[0][0].Data.Life)
			}
		})
	}
}
func TestNewBall(t *testing.T) {
	canvas := NewCanvas(utils.CanvasSize, utils.GridSize)
	testCases := []struct {
		name                                 string
		x, y, radius, index                  int
		expectedX, expectedY, expectedRadius int
	}{
		{
			"TestCase1",
			10, 10, 0, 1,
			10, 10, utils.BallSize,
		},
		{
			"TestCase2",
			10, 20, 30, 1,
			10, 20, 30,
		},
	}
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			ball := NewBall(canvas, tc.x, tc.y, tc.radius, tc.index)
			if ball.X != tc.expectedX {
				t.Errorf("Expected X to be %d, but got %d", tc.expectedX, ball.X)
			}
			if ball.Y != tc.expectedY {
				t.Errorf("Expected Y to be %d, but got %d", tc.expectedY, ball.Y)
			}
			if ball.Radius != tc.expectedRadius {
				t.Errorf("Expected Radius to be %d, but got %d", tc.expectedRadius, ball.Radius)
			}

			if ball.Canvas != canvas {
				t.Errorf("Expected Canvas to be %v, but got %v", canvas, ball.Canvas)
			}
			if ball.Index != tc.index {
				t.Errorf("Expected Index to be %d, but got %d", tc.index, ball.Index)
			}
		})
	}
}
package game

import (
	"testing"
)

func TestNewBrickData(t *testing.T) {
	type NewBrickDataTestCase struct {
		typeOfCell string
		life       int
		expected   *BrickData
	}

	testCases := []NewBrickDataTestCase{
		{typeOfCell: "Brick", life: 0, expected: &BrickData{Type: "Brick", Life: 1}},
		{typeOfCell: "Brick", life: 2, expected: &BrickData{Type: "Brick", Life: 2}},
		{typeOfCell: "Empty", life: 0, expected: &BrickData{Type: "Empty", Life: 0}},
		{typeOfCell: "Empty", life: 2, expected: &BrickData{Type: "Empty", Life: 0}},
	}

	for _, test := range testCases {
		result := NewBrickData(test.typeOfCell, test.life)
		if !result.Compare(test.expected) {
			t.Errorf("Expected %v for typeOfCell %s and life %d, got %v", test.expected, test.typeOfCell, test.life, result)
		}
	}
}

func TestBrickData_Compare(t *testing.T) {
	type CompareBrickDataTestCase struct {
		data         *BrickData
		comparedData *BrickData
		expected     bool
	}

	testCases := []CompareBrickDataTestCase{
		{&BrickData{Type: "Brick", Life: 1}, &BrickData{Type: "Brick", Life: 1}, true},
		{&BrickData{Type: "Empty", Life: 0}, &BrickData{Type: "Empty", Life: 0}, true},
		{&BrickData{Type: "Brick", Life: 2}, &BrickData{Type: "Brick", Life: 1}, false},
		{&BrickData{Type: "Empty", Life: 0}, &BrickData{Type: "Brick", Life: 0}, false},
	}

	for _, test := range testCases {
		result := test.data.Compare(test.comparedData)
		if result != test.expected {
			t.Errorf("Expected CompareBrickData(%v, %v) to return %v, got %v", test.data, test.comparedData, test.expected, result)
		}
	}
}

func TestCell_Compare(t *testing.T) {
	type CompareCellsTestCase struct {
		cell         Cell
		comparedCell Cell
		expected     bool
	}

	testCases := []CompareCellsTestCase{
		{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}, Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}, true},
		{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}, Cell{X: 0, Y: 0, Data: &BrickData{Type: "Empty", Life: 1}}, false},
		{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}, Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 2}}, false},
		{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Empty", Life: 0}}, Cell{X: 0, Y: 0, Data: &BrickData{Type: "Empty", Life: 0}}, true},
	}

	for _, test := range testCases {
		result := test.cell.Compare(test.comparedCell)
		if result != test.expected {
			t.Errorf("Expected CompareCells(%v, %v) to return %v, got %v", test.cell, test.comparedCell, test.expected, result)
		}
	}
}

func TestNewCell(t *testing.T) {
	type NewCellTestCase struct {
		x          int
		y          int
		life       int
		typeOfCell string
		expected   Cell
	}

	testCases := []NewCellTestCase{
		{0, 0, 0, "Brick", Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}},
		{1, 2, 3, "Empty", Cell{X: 1, Y: 2, Data: &BrickData{Type: "Empty", Life: 0}}},
		{4, 5, 2, "Brick", Cell{X: 4, Y: 5, Data: &BrickData{Type: "Brick", Life: 2}}},
	}

	for _, test := range testCases {
		result := NewCell(test.x, test.y, test.life, test.typeOfCell)
		if !result.Compare(test.expected) {
			t.Errorf("Expected %v, got %v", test.expected, result)
		}
	}
}
package game

import (
	"fmt"
	"testing"

	"github.com/lguibr/pongo/utils"
)

func TestNewCanvas(t *testing.T) {
	type testCase struct {
		size, gridSize int
		panics         bool
	}
	testCases := []testCase{
		{0, 0, false},
		{100, 0, true},
		{0, 8, false},
		{100, 7, true},
		{90, 6, false},
		{10, 100, true},
		{100, 5, true},
	}
	for index, tc := range testCases {
		panics, _ := utils.AssertPanics(t, func() { NewCanvas(tc.size, tc.gridSize) }, fmt.Sprintf("- Code did not panic on index %d", index))
		if panics != tc.panics {
			t.Errorf("Code did not panic on index %d", index)
		}
	}
}
package game

import (
	"encoding/json"
	"fmt"
	"math/rand"
	"time"

	"github.com/lguibr/pongo/utils"
)

type Game struct {
	Canvas  *Canvas    `json:"canvas"`
	Players [4]*Player `json:"players"`
}

func StartGame() *Game {
	rand.Seed(time.Now().UnixNano())

	canvas := NewCanvas(0, 0)
	canvas.Grid.Fill(0, 0, 0, 0)

	players := [4]*Player{}

	game := Game{
		Canvas:  canvas,
		Players: players,
	}

	return &game
}

func (game *Game) ToJson() []byte {
	gameBytes, err := json.Marshal(game)
	if err != nil {
		fmt.Println(err)
		return []byte{}
	}
	return gameBytes
}

func (game *Game) SubscribeBall(ball *Ball) {
	go func() {

		for {

			if game.Players[ball.Index] == nil {
				fmt.Println("player ball", ball.Index, "disconnected")
				return
			}

			ball.Move()
			ball.CollidePaddles(game.Players)
			ball.CollideCells()
			ball.CollideWalls()

			time.Sleep(utils.Period)
		}
	}()
}

func (game *Game) SubscribePaddle(paddle *Paddle) {
	go func() {
		for {

			if game.Players[paddle.Index] == nil {
				fmt.Println("player paddle", paddle.Index, "disconnected")
				return
			}

			paddle.Move()
			time.Sleep(utils.Period)
		}
	}()
}

func (game *Game) SubscribePlayer() (func(), *Player) {
	if !game.HasPlayer() {
		game.Canvas.Grid.Fill(0, 0, 0, 0)
	}
	index := game.GetNextIndex()
	playerId := "player" + fmt.Sprint(index)

	player := NewPlayer(game.Canvas, index, playerId)

	game.Players[index] = player

	for _, ball := range player.Balls {
		if ball == nil {
			continue
		}
		game.SubscribeBall(ball)
	}
	game.SubscribePaddle(player.Paddle)

	return func() { game.UnSubscribePlayer(index) }, player
}

func (game *Game) UnSubscribePlayer(index int) {
	fmt.Println("UnSubscribePlayer of index: ", index)
	game.Players[index].Balls = nil
	game.Players[index].Paddle = nil
	game.Players[index] = nil
}

func (game *Game) GetNextIndex() int {
	for i, player := range game.Players {
		if player == nil {
			return i
		}
	}
	return 0
}

func (game *Game) HasPlayer() bool {
	for _, player := range game.Players {
		if player != nil {
			return true
		}
	}
	return false
}
package game

import (
	"fmt"
	"reflect"
	"testing"

	"github.com/lguibr/pongo/utils"
)

func TestNewPlayer(t *testing.T) {
	type NewPlayerTestCase struct {
		canvas         *Canvas
		index          int
		id             string
		expectedPlayer *Player
	}
	canvas := &Canvas{Width: 800, Height: 600}
	balls := []*Ball{
		NewBall(canvas, 0, 0, 0, 1),
	}
	color := utils.NewRandomColor()
	testCases := []NewPlayerTestCase{
		{
			canvas: canvas,
			index:  1,
			id:     "player1",
			expectedPlayer: &Player{
				Index:  1,
				Id:     "player1",
				Canvas: canvas,
				Color:  color,
				Paddle: NewPaddle(canvas, 1),
				Balls:  balls,
			}},
		{
			canvas: canvas,
			index:  2,
			id:     "player2",
			expectedPlayer: &Player{
				Index:  2,
				Id:     "player2",
				Canvas: canvas,
				Color:  color,
				Paddle: NewPaddle(canvas, 2),
				Balls:  balls,
			}},
	}

	for _, test := range testCases {
		result := NewPlayer(test.canvas, test.index, test.id)
		fmt.Println("result", result)
		fmt.Println("test.expectedPlayer", test.expectedPlayer)

		//INFO Can't compare pointers
		result.Color = test.expectedPlayer.Color
		result.Paddle = test.expectedPlayer.Paddle
		result.Balls = test.expectedPlayer.Balls

		if !reflect.DeepEqual(result, test.expectedPlayer) {
			t.Errorf("Expected player %v, got \n%v", test.expectedPlayer, result)
		}
	}
}
package game

import (
	"testing"
)

func TestGrid_LineIntersectedCellIndices(t *testing.T) {

	type LineIntersectedCellIndicesCase struct {
		GridSize        int
		Line            [2][2]int
		ExpectedIndices [][2]int
	}

	cases := []LineIntersectedCellIndicesCase{
		{
			GridSize:        2,
			Line:            [2][2]int{{0, 0}, {1, 1}},
			ExpectedIndices: [][2]int{{0, 0}, {0, 1}, {1, 0}, {1, 1}},
		},
		{
			GridSize:        2,
			Line:            [2][2]int{{0, 0}, {1, 0}},
			ExpectedIndices: [][2]int{{0, 0}, {1, 0}},
		},
		{
			GridSize:        2,
			Line:            [2][2]int{{0, 0}, {0, 1}},
			ExpectedIndices: [][2]int{{0, 0}, {0, 1}},
		},
		{
			GridSize:        2,
			Line:            [2][2]int{{0, 0}, {0, 0}},
			ExpectedIndices: [][2]int{{0, 0}},
		},
	}

	for i := 0; i < len(cases); i++ {
		line := cases[i].Line
		expectedIndices := cases[i].ExpectedIndices
		gridSize := cases[i].GridSize

		canvas := NewGrid(gridSize)
		indices := canvas.LineIntersectedCellIndices(10, line)

		if len(indices) != len(expectedIndices) {
			t.Errorf("Expected %v indices, got %v", len(expectedIndices), len(indices))
		}

		for i, expected := range expectedIndices {
			currentValue := indices[i]
			if expected != currentValue {
				t.Errorf("Expected index %v, got %v", expected, currentValue)
			}
		}
	}

}

func TestGrid_NewGrid(t *testing.T) {
	gridSize := 5
	grid := NewGrid(gridSize)

	// Check the grid size
	if len(grid) != gridSize {
		t.Errorf("Expected grid to have length %d, but got %d", gridSize, len(grid))
	}
	if len(grid[0]) != gridSize {
		t.Errorf("Expected grid to have width %d, but got %d", gridSize, len(grid[0]))
	}

	// Check that all cells are empty
	for i := range grid {
		for j := range grid[i] {
			if grid[i][j].Data.Type != "Empty" {
				t.Errorf("Expected cell at position (%d, %d) to be empty, but got %s", i, j, grid[i][j].Data.Type)
			}
			if grid[i][j].Data.Life != 0 {
				t.Errorf("Expected cell at position (%d, %d) to have life 0, but got %d", i, j, grid[i][j].Data.Life)
			}
		}
	}
}
func TestCreateQuarterGridSeed(t *testing.T) {
	type TestCreateQuarterGridSeedTestCase struct {
		gridSize                int
		numberOfVectors         int
		maxVectorSize           int
		expectedBrickCellsCount float64
	}

	testCases := []TestCreateQuarterGridSeedTestCase{
		{10, 5, 5, float64(5 * 5)},
		{20, 10, 8, float64(10 * 8)},
		{30, 15, 12, float64(15 * 12)},
	}

	for _, test := range testCases {
		for i := 0; i < 100; i++ {

			// set up test grid
			grid := Grid{}
			for i := 0; i < test.gridSize; i++ {
				row := []Cell{}
				for j := 0; j < test.gridSize; j++ {
					cell := Cell{X: i, Y: j, Data: &BrickData{Type: "Empty", Life: 0}}
					row = append(row, cell)
				}
				grid = append(grid, row)
			}

			grid.CreateQuarterGridSeed(test.numberOfVectors, test.maxVectorSize)

			// check that the correct number of cells have been modified
			count := 0
			for i := range grid {
				for j := range grid[i] {
					if grid[i][j].Data.Type == "Brick" {
						count += grid[i][j].Data.Life
					}
				}
			}
			if float64(count) > test.expectedBrickCellsCount {
				t.Errorf("Expected %f Brick cells, got %d", test.expectedBrickCellsCount, count)
			}

			// check that all modified cells are in the top-left quarter of the grid
			for i := range grid {
				for j := range grid[i] {
					if grid[i][j].Data.Type == "Brick" {
						if i > (test.gridSize/2-1) || j > (test.gridSize/2-1) {
							t.Errorf("Brick cell at (%d, %d) is not in the top-left quarter of the grid", i, j)
						}
					}
				}
			}
		}
	}
}

func TestGrid_FillGridWithQuarterGrids(t *testing.T) {
	type FillGridWithQuarterGridsTestCase struct {
		q1, q2, q3, q4 Grid
		expectedGrid   Grid
	}

	testCases := []FillGridWithQuarterGridsTestCase{

		{
			// Test case 2: q1, q2, q3, and q4 have different values
			q1: Grid{{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}}},
			q2: Grid{{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Empty", Life: 0}}}},
			q3: Grid{{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 2}}}},
			q4: Grid{{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Empty", Life: 0}}}},
			expectedGrid: Grid{
				{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}, Cell{X: 0, Y: 1, Data: &BrickData{Type: "Empty", Life: 0}}},
				{Cell{X: 1, Y: 0, Data: &BrickData{Type: "Brick", Life: 2}}, Cell{X: 1, Y: 1, Data: &BrickData{Type: "Empty", Life: 0}}},
			},
		},
	}

	for _, test := range testCases {
		grid := NewGrid(len(test.q1) * 2)
		grid.FillGridWithQuarterGrids(test.q1, test.q2, test.q3, test.q4)
		match := grid.Compare(test.expectedGrid)
		if !match {
			t.Errorf("Expected %v, got %v", test.expectedGrid, grid)
		}
	}

}

func TestGrid_Rotate(t *testing.T) {

	type RotateTestCase struct {
		grid     Grid
		expected Grid
	}

	testCases := []RotateTestCase{
		{
			grid: Grid{
				{NewCell(0, 0, 0, "Empty"), NewCell(0, 1, 0, "Empty")},
				{NewCell(1, 0, 0, "Empty"), NewCell(1, 1, 0, "Empty")},
			},
			expected: Grid{
				{NewCell(1, 0, 0, "Empty"), NewCell(0, 0, 0, "Empty")},
				{NewCell(1, 1, 0, "Empty"), NewCell(0, 1, 0, "Empty")},
			},
		},
		{
			grid: Grid{
				{NewCell(0, 0, 0, "Empty"), NewCell(0, 1, 0, "Empty"), NewCell(0, 2, 0, "Empty")},
				{NewCell(1, 0, 0, "Empty"), NewCell(1, 1, 0, "Empty"), NewCell(1, 2, 0, "Empty")},
				{NewCell(2, 0, 0, "Empty"), NewCell(2, 1, 0, "Empty"), NewCell(2, 2, 0, "Empty")},
			},
			expected: Grid{
				{NewCell(2, 0, 0, "Empty"), NewCell(1, 0, 0, "Empty"), NewCell(0, 0, 0, "Empty")},
				{NewCell(2, 1, 0, "Empty"), NewCell(1, 1, 0, "Empty"), NewCell(0, 1, 0, "Empty")},
				{NewCell(2, 2, 0, "Empty"), NewCell(1, 2, 0, "Empty"), NewCell(0, 2, 0, "Empty")},
			},
		},
		{
			grid: Grid{
				{NewCell(0, 0, 0, "Empty")},
			},
			expected: Grid{
				{NewCell(0, 0, 0, "Empty")},
			},
		},
	}

	for _, test := range testCases {
		result := test.grid.Rotate()
		if !result.Compare(test.expected) {
			t.Errorf("Expected %v, got %v", test.expected, result)
		}
	}
}

func TestGrid_RandomWalker(t *testing.T) {
	type RandomWalkerTestCase struct {
		grid        Grid
		steps       int
		totalBricks int
	}

	testCases := []RandomWalkerTestCase{
		{
			grid:        NewGrid(10),
			steps:       10,
			totalBricks: 10,
		},
		{
			grid:        NewGrid(10),
			steps:       100,
			totalBricks: 100,
		},
		{
			grid:        NewGrid(10),
			steps:       1000,
			totalBricks: 1000,
		},
	}

	for _, test := range testCases {
		test.grid.RandomWalker(test.steps)
		totalBricks := 0
		for i := range test.grid {
			for j := range test.grid[i] {
				if test.grid[i][j].Data.Type == "Brick" {
					totalBricks += test.grid[i][j].Data.Life
				}
			}
		}
		if totalBricks != test.totalBricks {
			t.Errorf("Expected %d bricks after %d steps, got %d", test.totalBricks, test.steps, totalBricks)
		}
	}
}

func TestGrid_Fill(t *testing.T) {
	type FillTestCase struct {
		grid            Grid
		numberOfVectors int
		maxVectorSize   int
		randomSteps     int
		randomWalkers   int
		totalBricks     int
	}

	testCases := []FillTestCase{
		{
			grid:            NewGrid(10),
			numberOfVectors: 2,
			maxVectorSize:   2,
			randomSteps:     2,
			randomWalkers:   2,
			totalBricks:     (2 * 2) + (2*2)*4, //INFO ( (numberOfVectors * maxVectorSize + ) + (randomWalkers * randomSteps)) * 4
		},
	}

	for _, test := range testCases {
		for i := 0; i < 100; i++ {

			test.grid.Fill(test.numberOfVectors, test.maxVectorSize, test.randomSteps, test.randomWalkers)
			totalBricks := 0
			for i := range test.grid {
				for j := range test.grid[i] {
					if test.grid[i][j].Data.Type == "Brick" {
						totalBricks += test.grid[i][j].Data.Life
					}
				}
			}
			if totalBricks > test.totalBricks {
				t.Errorf("Expected max of %d bricks after %d steps, got %d", test.totalBricks, test.randomSteps, totalBricks)
			}
		}

	}
}

func TestGrid_Compare(t *testing.T) {
	testCases := []struct {
		name   string
		grid   Grid
		grid2  Grid
		result bool
	}{
		{
			name: "Grids are the same",
			grid: Grid{
				{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}, Cell{X: 0, Y: 1, Data: &BrickData{Type: "Brick", Life: 2}}},
				{Cell{X: 1, Y: 0, Data: &BrickData{Type: "Empty", Life: 0}}, Cell{X: 1, Y: 1, Data: &BrickData{Type: "Brick", Life: 1}}},
			},
			grid2: Grid{
				{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}, Cell{X: 0, Y: 1, Data: &BrickData{Type: "Brick", Life: 2}}},
				{Cell{X: 1, Y: 0, Data: &BrickData{Type: "Empty", Life: 0}}, Cell{X: 1, Y: 1, Data: &BrickData{Type: "Brick", Life: 1}}},
			},
			result: true,
		},
		{
			name: "Grids have different size",
			grid: Grid{
				{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}, Cell{X: 0, Y: 1, Data: &BrickData{Type: "Brick", Life: 2}}},
				{Cell{X: 1, Y: 0, Data: &BrickData{Type: "Empty", Life: 0}}, Cell{X: 1, Y: 1, Data: &BrickData{Type: "Brick", Life: 1}}},
			},
			grid2: Grid{
				{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}},
			},
			result: false,
		},
		{
			name: "Grids have different column size",
			grid: Grid{
				{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}, Cell{X: 0, Y: 1, Data: &BrickData{Type: "Brick", Life: 2}}},
				{Cell{X: 1, Y: 0, Data: &BrickData{Type: "Empty", Life: 0}}, Cell{X: 1, Y: 1, Data: &BrickData{Type: "Brick", Life: 1}}},
				{Cell{X: 1, Y: 0, Data: &BrickData{Type: "Empty", Life: 0}}, Cell{X: 1, Y: 1, Data: &BrickData{Type: "Brick", Life: 1}}},
			},
			grid2: Grid{
				{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}, Cell{X: 0, Y: 1, Data: &BrickData{Type: "Brick", Life: 2}}},
				{Cell{X: 1, Y: 0, Data: &BrickData{Type: "Empty", Life: 0}}, Cell{X: 1, Y: 1, Data: &BrickData{Type: "Brick", Life: 1}}},
			},

			result: false,
		},
		{
			name: "Grids have different row size",
			grid: Grid{
				{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}, Cell{X: 0, Y: 1, Data: &BrickData{Type: "Brick", Life: 2}}},
				{Cell{X: 1, Y: 0, Data: &BrickData{Type: "Empty", Life: 0}}, Cell{X: 1, Y: 1, Data: &BrickData{Type: "Brick", Life: 1}}},
				{Cell{X: 1, Y: 0, Data: &BrickData{Type: "Empty", Life: 0}}, Cell{X: 1, Y: 1, Data: &BrickData{Type: "Brick", Life: 1}}},
			},
			grid2: Grid{
				{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}},
				{Cell{X: 1, Y: 0, Data: &BrickData{Type: "Empty", Life: 0}}},
				{Cell{X: 1, Y: 0, Data: &BrickData{Type: "Empty", Life: 0}}},
			},

			result: false,
		},
		{
			name: "Grids have different data",
			grid: Grid{
				{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}, Cell{X: 0, Y: 1, Data: &BrickData{Type: "Brick", Life: 2}}},
				{Cell{X: 1, Y: 0, Data: &BrickData{Type: "Empty", Life: 0}}, Cell{X: 1, Y: 1, Data: &BrickData{Type: "Brick", Life: 1}}},
			},
			grid2: Grid{
				{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 2}}, Cell{X: 0, Y: 1, Data: &BrickData{Type: "Brick", Life: 2}}},
				{Cell{X: 1, Y: 0, Data: &BrickData{Type: "Empty", Life: 0}}, Cell{X: 1, Y: 1, Data: &BrickData{Type: "Brick", Life: 2}}},
			},
			result: false,
		},
		{
			name:   "Grids is empty",
			grid:   Grid{},
			grid2:  Grid{},
			result: true,
		},
		{
			name:   "One grid is nil, the other is empty",
			grid:   nil,
			grid2:  Grid{},
			result: true,
		},
		{
			name:   "Both grids are nil",
			grid:   nil,
			grid2:  nil,
			result: true,
		},
		{
			name:   "One element grid and nil grid",
			grid:   Grid{{Cell{X: 0, Y: 0, Data: &BrickData{Type: "Brick", Life: 1}}}},
			grid2:  nil,
			result: false,
		},
	}
	for _, test := range testCases {
		result := test.grid.Compare(test.grid2)
		if result != test.result {
			t.Errorf("Test case '%s' failed: expected %v, got %v", test.name, test.result, result)
		}
	}
}
